Module 13
Will be using Sequelize (object relational mapping [ORM] library) to simplify MySQL queries,
add password hashing for secure passwords, connect app to JawsDB (MySQL addon for
Heroku)
Also will be using: Dotenv (Node.js module to load env vars from .env file to process.env) and
bcrypt (Node.js library to allow password hashing)
Goal: have a working API with data that spans multiple related SQL tables by havin Javascript and SQL communicate with each other via Sequelize.

13.1
start with initializing node.js, adding packages, installing dependancies:
- `npm init -y`
    by using -y, update `package.json` to `"main": "index.js"` to `"main": "server.js"` and add `"start": "node server.js"`

create `.gitignore` and add `node_modules/` and `.DS_Store`
create `server.js`
create folders `modles` `routes` `config` `db`
execute `npm install express sequelize mysql2`

Sequelize: promise based Node.js ORM for Postgres, MySQL, SQLite, and Microsoft SQL Server. 
    javascript library that works with any dialect of SQL (using MySQL in thsi lesson)
Biggest benefit is being able to use object-oriented concepts to model database tables using JavaScript classes. Lets us add validators and custom rules to SQL data. 
    just have to create database, then start Sequelize and it will create tables for us.

create connection to db, then set up env var to hide password so noone can see once uploaded to GitHub

install dotenv `npm install dotenv`
    then install `.env` at root
    put in db name, user, pass, and load into `connection.js`

sequelize has its own model class where we can create our own JavaScript class and define cloumns, datatypes, and any other rules we define

define Model object. everytime we create a new User object extended from Model, it will inherit all of Model functionality including methods for CRUD operations. `init( )` execution actually provides context as to how those inherited methods should work

naming convention along with use of HTTP methods follow a famou API architectural pattern called REST (REpresntational State Transfer). building an API in this pattern is called a RESTful API
    guidelines: name endpoints in a way that describes the data you are interfacing with ex `/api/users`
    use HTTP methods like `GET, POST, PUT, DELETE` to describe actions being performed to interface with that endpoing ex `GET /api/users`
    use proper HTTP status codes like `400, 404, 500` for request errs

after creating users and using GET to retrieve user info, will also see psasword. to protect passwords, can update GET to not return password data.

13.2
MySQL database info is stored as plaintext, aka cleartext. therefore stored in a readable format which is very vulnerable to security breach and being stolen
therefore in this lesson, will be hashing password
Hashing: performs a one-way transformation on a password, turning it into another string, called 'hashed password'. Practically impossible to go the other way and turn it back into the original password.
    the moment an account is created, we must hash the plaintext password before it is stored into the database.    
        for this, `bcrypt` will be used to perform the hashing function. this has a proven consistent track record of security
            execute `npm install bcrypt`

documentation recommends to use async function to return the hashed password in a Promise. This will autogen a salt. `saltRounds` parameter is known as the cost factor and controls how many rounds of hashing are done by the bcrypt algorithm. the more hashing rounds, the longer it takes to hash, the more time it takes to crack using brute-force attacks

Hooks (special sequelize functions): aka lifecycle events, hooks are functions that are called before or after calls in Sequelize.
    to use hooks, must pass in another object labelled `hooks` to `User.init( )` function

Hooks have semantic names that declare when they can be called. in our case, we want to hash password just before user is created and stored in database, so `beforeCreate( )` hook will be used

once password is hashed, we need to allow users to be able to log in. first they will be verified via email and password (since email is more unique and duplicate usernames could be present)

remember: GET carries request parameter appended in URL string, POST carries request parametere in `req.body` (more secure)

bcrypt has a `compare` (async by default which is better for live servers) (or `.compareSync( )` which we will use in this example, sync version) method that checks passwords via two parameters:
    - plaintext pass from user
    - hashed password from database
    compares the two and if `compare = true` then verification complete
need an instance method which in OOP makes use of information (Ex properties) specific to that object
    will do this in `User` model to access password property of each user instance

13.3
Sequelize has a way of dynamically dropping/creating tables to overwrite existing ones to establish new associations/updates

at this point, after dropping and recreating tables, need to repopulate tables since Foreign Key Constraint Error dictates a post MUST have a user